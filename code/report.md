好的，我会尽力帮你完成3.2和3.3节的介绍过程部分，包括相关的linux内核背景介绍。以下是我的初步写作：

3.2 查询进程信息
- 介绍查询进程信息模块的输入、输出和处理过程

  - 输入：用户通过命令行或者图形界面输入要查询的进程的标识，如进程号、进程名等。
  - 输出：用户得到查询的进程的相关信息，如进程状态、优先级、内存使用、运行时间等。
  - 处理过程：查询进程信息模块首先根据用户输入的进程标识，在内核中查找对应的**task_struct**结构体，这是一个描述进程所有信息的结构体，位于**linux/include/linux/sched.h**中²。如果找到了匹配的**task_struct**结构体，就从中提取出需要输出的信息，并返回给用户；如果没有找到，就返回一个错误提示。

- 举例说明查询进程信息模块的功能效果

  - 例如，用户输入`ps -p 1`命令，表示要查询进程号为1的进程的信息。查询进程信息模块就会在内核中遍历一个双向链表，找到**task_struct**结构体中**pid**字段为1的结构体¹。然后从该结构体中读取出进程名（**comm**字段）、状态（**state**字段）、优先级（**prio**字段）等信息，并按照一定的格式输出给用户。输出结果类似于：

    ```
    PID TTY          TIME CMD
    1 ?        00:00:01 init
    ```

- 相关的linux内核背景介绍

  - Linux内核采用了一种称为PCB（Process Control Block）的数据结构来管理和控制进程。PCB是一个包含了进程所有信息和状态的结构体，它在内核中被定义为**task_struct**类型²。每个PCB都有一个唯一的标识符，即进程号（PID），它是一个整数，用来区分不同的进程。
  - Linux内核使用了一个双向链表来链接所有存在的PCB，这个链表被称为任务队列（task list）。链表中的每个节点都是一个指向PCB的指针，而每个PCB中都有一个指向前驱和后继节点的指针（**tasks**字段）。链表的头节点是一个特殊的PCB，它代表了系统中第一个创建的进程，即init进程（PID为1）。init进程是所有其他用户态进程的祖先，它负责启动系统服务和应用程序。
  - Linux内核提供了一些函数和宏来遍历任务队列，以便查找或操作特定的PCB。例如，**for_each_process()**宏可以遍历任务队列中所有活动状态（非僵尸状态）的PCB；**find_task_by_pid()**函数可以根据给定的PID在任务队列中查找对应的PCB；**get_current()**函数可以返回当前正在运行的PCB³。

3.3 查询进程打开的文件和网络地址
- 介绍查询进程打开的文件和网络地址模块的输入、输出和处理过程

  - 输入：用户通过命令行或者图形界面输入要查询的进程的标识，如进程号、进程名等。
  - 输出：用户得到查询的进程打开的文件和网络地址的列表，包括文件名、文件描述符、网络协议、本地地址、远端地址等。
  - 处理过程：查询进程打开的文件和网络地址模块首先根据用户输入的进程标识，在内核中查找对应的**task_struct**结构体，这是一个描述进程所有信息的结构体，位于**linux/include/linux/sched.h**中²。如果找到了匹配的**task_struct**结构体，就从中获取该进程打开的文件表（**files**字段），这是一个指向**files_struct**结构体的指针，位于**linux/include/linux/fdtable.h**中²。该结构体中有一个数组（**fd_array[]**字段），存放了该进程打开的所有文件描述符。对于每个文件描述符，模块会根据其类型（普通文件或者套接字），分别从相应的数据结构中读取出文件名或者网络地址等信息，并返回给用户；如果没有找到，就返回一个错误提示。

- 举例说明查询进程打开的文件和网络地址模块的功能效果

  - 例如，用户输入`lsof -p 1234`命令，表示要查询进程号为1234的进程打开的文件和网络地址。查询进程打开的文件和网络地址模块就会在内核中遍历一个双向链表，找到**task_struct**结构体中**pid**字段为1234的结构体¹。然后从该结构体中获取该进程打开的文件表，并遍历其中每个文件描述符。对于普通文件，模块会从其对应的inode结构体中读取出文件名；对于套接字，模块会从其对应的socket结构体中读取出网络协议、本地地址、远端地址等信息，并按照一定的格式输出给用户。输出结果类似于：

    ```
    COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF     NODE NAME
    bash    1234 root  cwd    DIR    8,1     4096        2 /
    bash    1234 root  rtd    DIR    8,1     4096        2 /
    bash    1234 root  txt    REG    8,1   980744   786435 /bin/bash
    bash    1234 root    0u   CHR 136,10      0t0       13 /dev/pts/10
    bash    1234 root    1u   CHR 136,10      0t0       13 /dev/pts/10
    bash    1234 root    2u   CHR 136,10      0t0       13 /dev/pts/10
    bash    1234 root   10u IPv4   1234      TCP localhost:ssh->localhost:12345 (ESTABLISHED)
    ```

- 相关的linux内核背景介绍

- Linux内核为每个打开或创建了一个文件或套接字（socket）对象分配了一个唯一编号称为文件描述符（file descriptor）。文件描述符是一个非负整数，在同一时刻只能被一个特定程序使用。Linux内核使用了一种称为VFS（Virtual File System）抽象层来管理不同类型（如普通文件、目录、设备、管道、套接字等）和来源（如本地磁盘、网络挂载等） 的文件对象。VFS提供了一组统一而通用 的接口函数来操作各种类型和来源 的文件对象⁴。
- Linux内核为每个打开或创建了一个VFS对象分配了一个称为file对象 的数据结构。file对象包含了与VFS对象相关联 的元数据信息 ，如引用计数、访问权限、访问位置等。file对象在内核中被定义为 **struct file **类型 ，位于 **linux/include/linux/fs.h ** 中² 。file对象还有一个指向VFS对象 的指针 ，

源: 与必应的对话， 2023/5/9
(1) 手把手教你获取Linux所有进程信息-腾讯云开发者社区-腾讯云. https://cloud.tencent.com/developer/article/1879175.
(2) 手把手教你获取Linux所有进程信息-腾讯云开发者社区-腾讯云. https://bing.com/search?q=linux%e5%86%85%e6%a0%b8%e8%bf%9b%e7%a8%8b%e4%bf%a1%e6%81%af.
(3) linux kernel中如何得到当前的进程信息 - CSDN博客. https://blog.csdn.net/shage001314/article/details/9101817.
(4) Linux中查看进程状态信息_linux查看进程详细信息_程序员在旅途的博客-CSDN博客. https://blog.csdn.net/qq_24754061/article/details/83350691.